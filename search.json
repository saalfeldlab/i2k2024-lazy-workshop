[
  {
    "objectID": "posts/04-cache/04-cache.html",
    "href": "posts/04-cache/04-cache.html",
    "title": "Lazy image processing with ImgLib2 cache",
    "section": "",
    "text": "In this notebook, we will learn how to use the ImgLib2 cache library to implement lazy processing workflows at the level of cells (blocks, chunks, boxes, hyperrectangles, Intervals). To make things a bit easier, we will compile and install a small helper library with useful functions. You can find it in /i2k2024-lazy-spark. Please build it:\nmvn clean package\nGreat! We can now add this as a dependency, together with everything else that we will use:\n\n\nCode\n%mavenRepo scijava.public https://maven.scijava.org/content/groups/public\n%maven org.scijava:scijava-common:2.99.0\n%maven mpicbg:mpicbg_:1.5.0\n%maven net.imglib2:imglib2:7.1.2\n%maven net.imglib2:imglib2-realtransform:4.0.3\n%maven net.imglib2:imglib2-ij:2.0.3\n%maven org.janelia.saalfeldlab:n5-ij:4.2.5\n%maven sc.fiji:bigdataviewer-core:10.6.2\n%maven net.haesleinhuepf:clij2_:2.5.3.1\n%jars ../../i2k2024-lazy-spark/target/i2k-2024-lazy-spark-0.0.1-SNAPSHOT.jar\n\n\n\n\nCode\nimport bdv.cache.SharedQueue;\nimport bdv.util.*;\nimport bdv.util.volatiles.VolatileViews;\nimport ij.ImagePlus;\nimport io.github.spencerpark.jupyter.kernel.display.common.*;\nimport io.github.spencerpark.jupyter.kernel.display.mime.*;\nimport mpicbg.ij.clahe.Flat;\nimport mpicbg.ij.plugin.NormalizeLocalContrast;\nimport net.imglib2.*;\nimport net.imglib2.algorithm.lazy.*;\nimport net.imglib2.cache.img.*;\nimport net.imglib2.converter.*;\nimport net.imglib2.img.display.imagej.*;\nimport net.imglib2.type.numeric.*;\nimport net.imglib2.type.numeric.integer.*;\nimport net.imglib2.type.numeric.real.*;\nimport net.imglib2.util.*;\nimport net.imglib2.view.*;\nimport org.janelia.saalfeldlab.i2k2024.*;\nimport org.janelia.saalfeldlab.i2k2024.ops.*;\nimport org.janelia.saalfeldlab.i2k2024.util.*;\nimport org.janelia.saalfeldlab.n5.*;\nimport org.janelia.saalfeldlab.n5.imglib2.N5Utils;\nimport org.janelia.saalfeldlab.n5.universe.N5Factory;\n\n\nAs before, we register image renderers, so we can see soemthing in the notebook.\n\n\nCode\ngetKernelInstance().getRenderer().createRegistration(RandomAccessibleInterval.class)\n    .preferring(MIMEType.IMAGE_PNG)\n    .supporting(MIMEType.IMAGE_JPEG, MIMEType.IMAGE_GIF)\n    .register((rai, context) -&gt; Image.renderImage(\n        ImageJFunctions.wrap(rai, rai.toString()).getBufferedImage(),\n        context));\n\n\nLet’s first define a source:\n\n\nCode\nvar n5Url = \"https://janelia-cosem.s3.amazonaws.com/jrc_hela-2/jrc_hela-2.n5\";\nvar n5Dataset = \"/em/fibsem-uint16/s3\";\n\nfinal var n5 = new N5Factory().openReader(n5Url);\nfinal RandomAccessibleInterval&lt;UnsignedShortType&gt; img = N5Utils.openVolatile(n5, n5Dataset);\n\n\nSLF4J: Failed to load class \"org.slf4j.impl.StaticLoggerBinder\".\nSLF4J: Defaulting to no-operation (NOP) logger implementation\nSLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details.\n\n\nFor processing, we will use ImgLib2 cached cell loaders. This is best done with a shared factory:\n\n\nCode\n/* create a cached image factory with reasonable default values */\nfinal var cacheFactory = new ReadOnlyCachedCellImgFactory(\n  new ReadOnlyCachedCellImgOptions()\n      .volatileAccesses(true)         //&lt; use volatile accesses for display\n      .cellDimensions(256, 256, 32)); //&lt; standard block size for this example\n\n\nNow some parameters:\n\n\nCode\nint scaleIndex = 3;\nfinal double scale = 1.0 / Math.pow(2, scaleIndex);\nfinal int blockRadius = (int)Math.round(1023 * scale);\n\n\nLet’s create our first lazy processed image:\n\n\nCode\n/* Use the ImageJ CLAHE plugin in an op to produce CLAHE enhanced cells */\nfinal var clahe = new ImageJStackOp&lt;&gt;(\n    Views.extendMirrorSingle(img),\n    fp -&gt; Flat.getFastInstance().run(\n        new ImagePlus(\"\", fp),\n        blockRadius,\n        256,\n        3.0f,\n        null,\n        false),\n    blockRadius,\n    0,\n    65535);\n\n/* create a lazy-generating cached cell image using the clahe op as a cell loader */\nfinal var clahed = cacheFactory.create(\n    img.dimensionsAsLongArray(),               //&lt; the size of the result\n    img.randomAccess().get().createVariable(), //&lt; the type that is used to generate the result pixels\n    clahe::accept);                            //&lt; the consumer that creates each cell\n\n\nLet’s look at clahed:\n\n\nCode\nvar clahedCrop = clahed.view().interval(\n    Intervals.createMinSize(\n        clahed.dimension(2) / 2, 0, clahed.dimension(2) / 2,\n        512, clahed.dimension(1), 1));\nclahedCrop;\n\n\n\n\n\n\n\n\n\n\n\nCode\n/* Use the ImageJ plugin local contrast normalization in an op to produce contrast enhanced cells */\nfinal var lcn =\n    new ImageJStackOp&lt;UnsignedShortType&gt;(\n        Views.extendMirrorSingle(img),\n        fp -&gt; NormalizeLocalContrast.run(\n            fp,\n            blockRadius,\n            blockRadius,\n            3f,\n            true,\n            true),\n        blockRadius,\n        0,\n        65535);\n\n/* create a lazy-generating cached cell image using the lcn op as a cell loader */\nfinal var lcned = cacheFactory.create(\n    img.dimensionsAsLongArray(),               //&lt; the size of the result\n    img.randomAccess().get().createVariable(), //&lt; the type that is used to generate the result pixels\n    lcn::accept);                              //&lt; the consumer that creates each cell\n\n\n\n\nCode\nvar lcnedCrop = lcned.view().interval(clahedCrop);\nlcnedCrop;\n\n\n\n\n\n\n\n\n\n\n\nCode\n/* Use the new ImageJ plugin contrast limited local contrast normalization in an op to produce contrast enhanced cells */\nfinal var cllcn =\n    new ImageJStackOp&lt;UnsignedShortType&gt;(\n        Views.extendMirrorSingle(img),\n        fp -&gt; new CLLCN(fp).run(\n            blockRadius,\n            blockRadius,\n            3f,\n            10,\n            0.5f,\n            true,\n            true,\n            true),\n        blockRadius,\n        0,\n        65535);\n\n/* create a lazy-generating cached cell image using the cllcn op as a cell loader */\nfinal var cllcned = cacheFactory.create(\n    img.dimensionsAsLongArray(),               //&lt; the size of the result\n    img.randomAccess().get().createVariable(), //&lt; the type that is used to generate the result pixels\n    cllcn::accept);                            //&lt; the consumer that creates each cell\n\n\n\n\nCode\nvar cllcnedCrop = cllcned.view().interval(clahedCrop);\ncllcnedCrop;\n\n\n\n\n\n\n\n\n\n\n\nCode\n/* Invert and float convert the image, then use the CLIJ2 DoG filter */\nfinal var inverted =\n    Converters.convert(img, (a, b) -&gt; b.setReal(0xffff - a.getRealDouble()), new FloatType());\nfinal var clij2Filter =\n    new CLIJ2FilterOp&lt;FloatType, FloatType&gt;(\n        Views.extendMirrorSingle(inverted), 20, 20, 20);\n    clij2Filter.setFilter(\n        (a, b) -&gt; clij2Filter.getClij2().differenceOfGaussian(a, b, 4, 4, 4, 3, 3, 3));\nfinal var clij2filtered = cacheFactory.create(\n    img.dimensionsAsLongArray(), //&lt; the size of the result\n    new FloatType(),             //&lt; the type that is used to generate the result pixels\n    clij2Filter::accept,         //&lt; the consumer that creates each cell\n    new ReadOnlyCachedCellImgOptions().cellDimensions(64, 64, 64));\n\n\n\n\nCode\nvar clij2filteredCrop = clij2filtered.view().interval(clahedCrop);\nclij2filteredCrop;\n\n\n\n\n\n\n\n\n\nAll this felt a bit non-interactive, so let’s see how it looks in BigDataViewer:\n\n\nCode\nfinal var queue = new SharedQueue(Math.max(1, Runtime.getRuntime().availableProcessors() - 1));\n\nBdvStackSource&lt;?&gt; bdv = null;\n\nbdv = BdvFunctions.show(\n    VolatileViews.wrapAsVolatile(\n        img,\n        queue),\n    n5Dataset,\n    BdvOptions.options());\nbdv.setDisplayRange(10000, 50000);\n\n\n\n\nCode\nbdv = BdvFunctions.show(\n    VolatileViews.wrapAsVolatile(\n        clahed,\n        queue),\n    n5Dataset + \" CLAHE\",\n    BdvOptions.options().addTo(bdv));\nbdv.setDisplayRange(10000, 50000);\n\n\n\n\nCode\nbdv = BdvFunctions.show(\n    VolatileViews.wrapAsVolatile(\n        lcned,\n        queue),\n    n5Dataset + \" LCN\",\n    BdvOptions.options().addTo(bdv));\nbdv.setDisplayRange(10000, 50000);\n\n\n\n\nCode\nbdv = BdvFunctions.show(\n    VolatileViews.wrapAsVolatile(\n        cllcned,\n        queue),\n    n5Dataset + \" CLLCN\",\n    BdvOptions.options().addTo(bdv));\nbdv.setDisplayRange(10000, 50000);\n\n\n\n\nCode\nbdv = BdvFunctions.show(\n    VolatileViews.wrapAsVolatile(\n        clij2filtered,\n        queue),\n    n5Dataset + \" CLIJ2 DoG\",\n    BdvOptions.options().addTo(bdv));\nbdv.setDisplayRange(-1000, 1000);\n\n\nGradients of CLAHE enhanced image:\n\n\nCode\n/* convert to a signed type that can capture the gradients */\nfinal var imgDoubles = Converters.convert(\n    clahed,\n    (a, b) -&gt; b.setReal(a.getRealDouble()),\n    new DoubleType());\n\n/* gradients X */\nfinal var gradientX = Functions.centerGradientRAI(imgDoubles, 0);\n/* gradients Y */\nfinal var gradientY = Functions.centerGradientRAI(imgDoubles, 1);\n/* gradients Z */\nfinal var gradientZ = Functions.centerGradientRAI(imgDoubles, 2);\n\n/* cache results */\nvar cachedGradientX = Caches.cache(gradientX, 16, 16, 16);\nvar cachedGradientY = Caches.cache(gradientY, 16, 16, 16);\nvar cachedGradientZ = Caches.cache(gradientZ, 16, 16, 16);\n\nbdv = BdvFunctions.show(\n    VolatileViews.wrapAsVolatile(cachedGradientX),\n    n5Dataset + \" CLAHE gradient x\",\nBdvOptions.options().addTo(bdv));\nbdv.setColor(new ARGBType(0xffff0000));\nbdv.setDisplayRange(-4000, 4000);\n\nbdv = BdvFunctions.show(\n    VolatileViews.wrapAsVolatile(cachedGradientY),\n    n5Dataset + \" CLAHE gradient y\",\n    BdvOptions.options().addTo(bdv));\nbdv.setColor(new ARGBType(0xff00ff00));\nbdv.setDisplayRange(-4000, 4000);\n\nbdv = BdvFunctions.show(\n    VolatileViews.wrapAsVolatile(cachedGradientZ),\n    n5Dataset + \" CLAHE gradient z\",\n    BdvOptions.options().addTo(bdv));\nbdv.setColor(new ARGBType(0xff0000ff));\nbdv.setDisplayRange(-4000, 4000);\n\n\nWe’ve now interactively inspected the results of our operation, and would like to process the entire dataset and save the output. Since saving requires that the data exists, we can simply save the incomplete lazy-cached result in parallel. This will trigger evaluation where data has not been generated:\n\n\nCode\nfinal var n5OutUrl = \"/home/saalfeld/tmp/jrc_hela-2.zarr\";\nfinal var n5OutGroup = \"/em/fibsem-uint16/processed/\";\n\n/* use the same attributes as source */\nvar attributes = n5.getDatasetAttributes(n5Dataset);\n\n/* create an N5 factory with reasonable defaults */\nfinal N5Factory n5Factory = new N5Factory()\n    .zarrDimensionSeparator(\"/\");\n\n/* working in parallel helps */\nfinal var exec = Executors.newFixedThreadPool(12);\n\ndisplay(\"Processing...\");\n\nfinal var timer = new org.janelia.saalfeldlab.i2k2024.util.Timer();\ntimer.start();\n\ntry (final N5Writer n5Out = n5Factory.openWriter(n5OutUrl)) {\n  N5Utils.save(\n    cachedGradientX,\n    n5Out,\n    n5OutGroup + \"clahe-gradient-x\",\n    attributes.getBlockSize(),\n    attributes.getCompression(),\n    exec);\n    \n  display(\"... x done in \" + timer.stop() + \"ms.\");\n  timer.start();\n\n  N5Utils.save(\n    cachedGradientY,\n    n5Out,\n    n5OutGroup + \"clahe-gradient-y\",\n    attributes.getBlockSize(),\n    attributes.getCompression(),\n    exec);\n\n  display(\"... y done in \" + timer.stop() + \"ms.\");\n  timer.start();\n\n  N5Utils.save(\n    cachedGradientZ,\n    n5Out,\n    n5OutGroup + \"clahe-gradient-z\",\n    attributes.getBlockSize(),\n    attributes.getCompression(),\n    exec);\n\n  display(\"... z done in \" + timer.stop() + \"ms.\");\n  timer.start();\n}\n\nexec.shutdown();\n\n\nProcessing...\n\n\n... x done in 96666.228947ms.\n\n\n... y done in 21813.889825ms.\n\n\n... z done in 21835.305614ms."
  },
  {
    "objectID": "posts/05-blocks/05-blocks.html",
    "href": "posts/05-blocks/05-blocks.html",
    "title": "Using the ImgLib2 blocks API",
    "section": "",
    "text": "As usual, we start by importing dependencies and registering RandomAcccessibleInterval notebook renderer.\n\n\nCode\n%mavenRepo scijava.public https://maven.scijava.org/content/groups/public\n%maven org.scijava:scijava-common:2.99.0\n%maven net.imglib2:imglib2-algorithm:0.17.1-SNAPSHOT\n%maven net.imglib2:imglib2:7.1.2\n%maven net.imglib2:imglib2-ij:2.0.3\n%maven sc.fiji:bigdataviewer-core:10.6.2\n%maven org.janelia.saalfeldlab:n5:3.3.0\n\n\n\n\nCode\nimport io.github.spencerpark.jupyter.kernel.display.common.*;\nimport io.github.spencerpark.jupyter.kernel.display.mime.*;\nimport net.imglib2.img.display.imagej.ImageJFunctions;\nimport net.imglib2.RandomAccessibleInterval;\n\ngetKernelInstance().getRenderer().createRegistration(RandomAccessibleInterval.class)\n    .preferring(MIMEType.IMAGE_PNG)\n    .supporting(MIMEType.IMAGE_JPEG, MIMEType.IMAGE_GIF)\n    .register((rai, context) -&gt; Image.renderImage(\n        ImageJFunctions.wrap(rai, rai.toString()).getBufferedImage(),\n        context));"
  },
  {
    "objectID": "posts/05-blocks/05-blocks.html#setting-up",
    "href": "posts/05-blocks/05-blocks.html#setting-up",
    "title": "Using the ImgLib2 blocks API",
    "section": "",
    "text": "As usual, we start by importing dependencies and registering RandomAcccessibleInterval notebook renderer.\n\n\nCode\n%mavenRepo scijava.public https://maven.scijava.org/content/groups/public\n%maven org.scijava:scijava-common:2.99.0\n%maven net.imglib2:imglib2-algorithm:0.17.1-SNAPSHOT\n%maven net.imglib2:imglib2:7.1.2\n%maven net.imglib2:imglib2-ij:2.0.3\n%maven sc.fiji:bigdataviewer-core:10.6.2\n%maven org.janelia.saalfeldlab:n5:3.3.0\n\n\n\n\nCode\nimport io.github.spencerpark.jupyter.kernel.display.common.*;\nimport io.github.spencerpark.jupyter.kernel.display.mime.*;\nimport net.imglib2.img.display.imagej.ImageJFunctions;\nimport net.imglib2.RandomAccessibleInterval;\n\ngetKernelInstance().getRenderer().createRegistration(RandomAccessibleInterval.class)\n    .preferring(MIMEType.IMAGE_PNG)\n    .supporting(MIMEType.IMAGE_JPEG, MIMEType.IMAGE_GIF)\n    .register((rai, context) -&gt; Image.renderImage(\n        ImageJFunctions.wrap(rai, rai.toString()).getBufferedImage(),\n        context));"
  },
  {
    "objectID": "posts/05-blocks/05-blocks.html#introduction",
    "href": "posts/05-blocks/05-blocks.html#introduction",
    "title": "Using the ImgLib2 blocks API",
    "section": "Introduction",
    "text": "Introduction\nThe ImgLib2 “blocks” API is about performing computations on blocks of (image) data more efficiently than going pixel-by-pixel using RandomAccess, Type, etc.\nA fundamental limitation of this framework is that it only works with NativeType, and (so far) only with those that map 1:1 to primitives. For example, UnsignedByteType works, but ComplexDoubleType does not.\n\nIdea\nThe idea is simple:\n\nEfficiently extract a region from a RandomAccessible&lt;T&gt; into a flat primitive array.\nImplement small, efficient functions that compute the output flat primitive array from the input flat primitive array. (Importantly, these functions don’t do anything “clever”: out-of-bounds extension is handled outside; if the input data requires padding, assume the input array is padded. No per-element type checks, etc. If the function should work on float[] and int[] inputs, we have two versions.)\nWrap and assemble the computed flat primitive arrays back into RandomAccessibleInterval.\n\nWe also provide some infrastructure for chaining intermediate ‘block’ operations.\n\n\nOutline\nThere are two levels of API:\n\nThe low-level PrimitiveBlocks and BlockProcessor deal with primitive java arrays.\nThe high-level BlockSupplier and UnaryBlockOperator wrap this in a layer of syntactic sugar and type-safety.\n\nWe look into the low-level API first. You’ll never have to use it unless you want to implement a new “blocks” algorithm, but it is useful to illustrate whats happening."
  },
  {
    "objectID": "posts/05-blocks/05-blocks.html#primitiveblocks",
    "href": "posts/05-blocks/05-blocks.html#primitiveblocks",
    "title": "Using the ImgLib2 blocks API",
    "section": "PrimitiveBlocks",
    "text": "PrimitiveBlocks\nLoad and show 2D image that we will to work with…\n\n\nCode\nimport ij.IJ;\nimport net.imglib2.*;\nimport net.imglib2.util.*;\nimport net.imglib2.position.*;\nimport net.imglib2.img.array.*;\nimport net.imglib2.type.numeric.real.*;\nimport net.imglib2.type.numeric.integer.*;\nimport net.imglib2.converter.RealTypeConverters;\nimport net.imglib2.img.display.imagej.ImageJFunctions;\n\n// var fn = \"/Users/pietzsch/workspace/data/DrosophilaWing.tif\";\n// var fn = \"https://mirror.imagej.net/ij/images/boats.gif\";\nvar fn = \"boats.gif\";\nRandomAccessibleInterval&lt;UnsignedByteType&gt; img = ImageJFunctions.wrap(IJ.openImage(fn));\n\ndisplay(img);\n\n\n\n\n\n\n\n\n\n89b8d9d7-72b6-4998-a81a-0e71ffe5c055\n\n\n\n\nCode\nvar crop = Intervals.createMinSize(350, 220, 64, 64);\nvar cropped = img.view().interval(crop).zeroMin();\ndisplay(cropped);\n\n\n\n\n\n\n\n\n\nee567bcf-71fa-4f9a-9df4-ea7c80a932e1\n\n\nFor any RandomAccessible&lt;T&gt; we can get a “block copier” using PrimitiveBlocks.of(...). As mentioned above, this only works with NativeType that map 1:1 to primitives.\nSo let’s get access to the blocks of our img:\n\n\nCode\nimport net.imglib2.blocks.PrimitiveBlocks;\n\nPrimitiveBlocks&lt;UnsignedByteType&gt; blocks = PrimitiveBlocks.of(img);\n\n\nWe can now extract data into a primitive array (byte[] for our UnsignedByteType image). We extract the top 4x4 pixels of the cropped area:\n\n\nCode\nint[] pos = {350, 220};\nint[] size = {4, 4};\nbyte[] array = new byte[4 * 4];\nblocks.copy(pos, array, size);\n\nArrays.toString(array)\n\n\n[119, -76, -55, -50, 83, -119, -69, -51, 67, 86, -116, -58, 63, 72, 95, -81]\n\n\nWhy are there negative numbers? Because we use Java’s (signed) byte to represent UnsignedByteType values.\nLet’s convert to IntType and extract a int[] block instead.\n\n\nCode\nRandomAccessibleInterval&lt;IntType&gt; converted = RealTypeConverters.convert(img, new IntType());\n\nPrimitiveBlocks&lt;IntType&gt; blocks = PrimitiveBlocks.of(converted);\nint[] array = new int[4 * 4];\nblocks.copy(pos, array, size);\n\nArrays.toString(array)\n\n\n[119, 180, 201, 206, 83, 137, 187, 205, 67, 86, 140, 198, 63, 72, 95, 175]\n\n\nNote that PrimitiveBlocks.of(...) understood the virtual type conversion.\nIt also understands many virtual coordinate transforms.\n\n\nCode\nvar croppedAndConverted = img.view()\n    .interval(crop)\n    .zeroMin()\n    .convert(IntType::new, (b,i) -&gt; i.set(b.get()));\n\nPrimitiveBlocks&lt;IntType&gt; blocks = PrimitiveBlocks.of(croppedAndConverted);\nint[] pos = {0, 0};\nint[] array = new int[4 * 4];\nblocks.copy(pos, array, size);\n\nArrays.toString(array)\n\n\n[119, 180, 201, 206, 83, 137, 187, 205, 67, 86, 140, 198, 63, 72, 95, 175]\n\n\n(Note that we copy starting from (0, 0) now, as the shift to (350, 220) happens in the View transform.)\nWhen PrimitiveBlocks.of(...) “understands” a View construction that ultimately end in CellImg, ArrayImg, etc., it and will create an optimized copier: Instead of using RandomAccess that checks for every pixel whether it enters a new Cell, whether it is out-of-bounds, etc., all these checks are precomputed and then relevant data from each Cell is copied in one go.\n\nDetails, details…\nThe speedup can be dramatic, in particular if the underlying source data is in a CellImg.  Here is for example results of CopyBenchmarkViewPrimitiveBlocks\n# JMH version: 1.35\n# VM version: JDK 17.0.3, OpenJDK 64-Bit Server VM, 17.0.3+7-LTS\n...\n\nBenchmark                                                  (oob)  (permute)  Mode  Cnt   Score   Error  Units\nCopyBenchmarkViewPrimitiveBlocks.benchmarkLoopBuilder       true       true  avgt    5  12,789 ± 0,285  ms/op\nCopyBenchmarkViewPrimitiveBlocks.benchmarkLoopBuilder       true      false  avgt    5   9,682 ± 0,152  ms/op\nCopyBenchmarkViewPrimitiveBlocks.benchmarkLoopBuilder      false       true  avgt    5  14,333 ± 0,099  ms/op\nCopyBenchmarkViewPrimitiveBlocks.benchmarkLoopBuilder      false      false  avgt    5  12,721 ± 0,123  ms/op\nCopyBenchmarkViewPrimitiveBlocks.benchmarkPrimitiveBlocks   true       true  avgt    5   0,541 ± 0,010  ms/op\nCopyBenchmarkViewPrimitiveBlocks.benchmarkPrimitiveBlocks   true      false  avgt    5   0,315 ± 0,024  ms/op\nCopyBenchmarkViewPrimitiveBlocks.benchmarkPrimitiveBlocks  false       true  avgt    5   0,570 ± 0,013  ms/op\nCopyBenchmarkViewPrimitiveBlocks.benchmarkPrimitiveBlocks  false      false  avgt    5   0,322 ± 0,008  ms/op\nIf a source RandomAccessible cannot be understood, PrimitiveBlocks.of(...) will return a fall-back implementation (based on LoopBuilder).  With the optional OnFallback argument of PrimitiveBlocks.of(...) it can be configured whether fall-back should be * silently accepted (ACCEPT), * a warning should be printed (WARN) – the default, * or an IllegalArgumentException thrown (FAIL). The warning/exception message explains why the source RandomAccessible requires fall-back.\n\n\nCode\nRandomAccessible&lt;UnsignedByteType&gt; func = new FunctionRandomAccessible&lt;&gt;(\n        2,\n        (pos, value) -&gt; value.set((int) (pos.getIntPosition(0) * pos.getIntPosition(1))),\n        UnsignedByteType::new);\n\nPrimitiveBlocks&lt;UnsignedByteType&gt; blocks = PrimitiveBlocks.of(func);\nint[] pos = {1, 1};\nbyte[] array = new byte[4 * 4];\nblocks.copy(pos, array, size);\n\nArrays.toString(array)\n\n\nThe RandomAccessible net.imglib2.position.FunctionRandomAccessible@6e4e6a73 is only be supported through the fall-back implementation of PrimitiveBlocks. \nCannot analyze view net.imglib2.position.FunctionRandomAccessible@6e4e6a73 of class FunctionRandomAccessible\n\n\n[1, 2, 3, 4, 2, 4, 6, 8, 3, 6, 9, 12, 4, 8, 12, 16]"
  },
  {
    "objectID": "posts/05-blocks/05-blocks.html#blockprocessor",
    "href": "posts/05-blocks/05-blocks.html#blockprocessor",
    "title": "Using the ImgLib2 blocks API",
    "section": "BlockProcessor",
    "text": "BlockProcessor\nOnce we can extract primitive arrays from RandomAccessibleInterval, the actual computation happens in BlockProcessor.\nThis happens in two steps: 1. Backward: Inverse-transform the desired target interval to determine which source data we need to provide to the BlockProcessor. 2. Forward: Push the source data through the BlockProcessor to compute the target data (both primitive arrays).\nTo try that, we’ll use a BlockProcessor for 2x downsampling. Normally we don’t use BlockProcessor directly, so the constructor of that one is not public. We need to extract it from a high-level operator (explained later):\n\n\nCode\nimport net.imglib2.algorithm.blocks.*;\nimport net.imglib2.algorithm.blocks.downsample.Downsample;\n\nBlockProcessor&lt;byte[], byte[]&gt; processor = Downsample\n                .createOperator(new UnsignedByteType(), ComputationType.FLOAT, Downsample.Offset.HALF_PIXEL, 2)\n                .blockProcessor();\n\n\n\n1. Backward: Inverse-transform the desired target interval to determine which source data we need to provide to the BlockProcessor.\nNow we can ask the processor which source interval we will need to produce a given target interval. (In this case, the source interval is 2x larger and appropriately shifted for downsampling).\n\n\nCode\nInterval interval = Intervals.createMinSize(200, 100, 64, 64);\nSystem.out.println(\"target interval = \" + Intervals.toString(interval));\n\nprocessor.setTargetInterval(interval);\nSystem.out.println(\"source interval = \" + Intervals.toString(processor.getSourceInterval()));\n\n\ntarget interval = [(200, 100) -- (263, 163) = 64x64]\nsource interval = [(400, 200) -- (527, 327) = 128x128]\n\n\n\n\n2. Forward: Push the source data through the BlockProcessor to compute the target data (both primitive arrays).\nWe first need to provide some source data for processing. We get that via PrimitiveBlocks.copy(...), where we specify the source pos/size as the source interval obtained from processor. (We can also ask processor to allocate a primitive array for holding the input data.)\n\n\nCode\nbyte[] sourceData = new byte[128 * 128]; // processor.getSourceBuffer();\nPrimitiveBlocks.of(img).copy(processor.getSourcePos(), sourceData, processor.getSourceSize());\n\n\nWe allocate a primitive array to hold the result, then call BlockProcessor.compute(...).\n\n\nCode\nbyte[] targetData = new byte[64 * 64];\nprocessor.compute(sourceData, targetData);\n\n\nFinally, we show the result wrapped as an ArrayImg, as well as the source area it was obtained from.\n\n\nCode\nvar downsampled = ArrayImgs.unsignedBytes(targetData, 64, 64);\ndisplay(downsampled);\ndisplay(img.view().interval(processor.getSourceInterval()));\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n5858c8c3-5e67-431f-9c81-a9c59d335974\n\n\nAs you can imagine, it is straightforward to chain BlockProcessors, sending the target interval backwards through the chain, and the source data forwards via approriate temporary intermediate arrays. In fact, our BlockProcessor is already such a concatenation (convert byte[] to float[], downsample float[] to float[], convert float[] to byte[]).\n\n\nCode\nSystem.out.println(processor.getClass());\n\n\nclass net.imglib2.algorithm.blocks.ConcatenatedBlockProcessor"
  },
  {
    "objectID": "posts/05-blocks/05-blocks.html#blocksupplier-and-unaryblockoperator",
    "href": "posts/05-blocks/05-blocks.html#blocksupplier-and-unaryblockoperator",
    "title": "Using the ImgLib2 blocks API",
    "section": "BlockSupplier and UnaryBlockOperator",
    "text": "BlockSupplier and UnaryBlockOperator\nWith the details out of the way, let’s look at how this is wrapped into a more ImgLib2-like API.\nThe BlockSupplier interface is more or less equivalent to PrimitiveBlocks. The above code works fine if you replace PrimitiveBlocks with BlockSupplier.\nBlockSupplier provides additional default methods for chaining operations, and support for wrapping into a CachedCellImg, etc. This is not available in imglib2 core, where PrimitiveBlocks lives, therefore the duplication… (BlockSupplier lives in imglib2-algorithm.)\n\n\nCode\nBlockSupplier&lt;UnsignedByteType&gt; blocks = BlockSupplier.of(img);\n\n\nThe UnaryBlockOperator&lt;S,T&gt; interface wraps BlockProcessor&lt;I,O&gt;. The generic parameters &lt;S,T&gt; are the ImgLib2 Types corresponding to the primitive array types &lt;I,O&gt;.\nHere is the downsampling operator we already used above:\n\n\nCode\nUnaryBlockOperator&lt;UnsignedByteType, UnsignedByteType&gt; operator =\n        Downsample.createOperator(new UnsignedByteType(), ComputationType.FLOAT, Downsample.Offset.HALF_PIXEL, 2);\n\n\n\nChaining operators\nUnaryBlockOperator knows the dimensionality of its source and target spaces as well as its source and target Types. So does BlockSupplier.\n\n\nCode\nSystem.out.println(\"blocks.numDimensions   = \" + blocks.numDimensions());\nSystem.out.println(\"blocks.type            = \" + blocks.getType().getClass().getSimpleName());\nSystem.out.println(\"op.numSourceDimensions = \" + operator.numSourceDimensions());\nSystem.out.println(\"op.sourceType          = \" + operator.getSourceType().getClass().getSimpleName());\nSystem.out.println(\"op.numTargetDimensions = \" + operator.numTargetDimensions());\nSystem.out.println(\"op.targetType          = \" + operator.getTargetType().getClass().getSimpleName());\n\n\nblocks.numDimensions   = 2\nblocks.type            = UnsignedByteType\nop.numSourceDimensions = 2\nop.sourceType          = UnsignedByteType\nop.numTargetDimensions = 2\nop.targetType          = UnsignedByteType\n\n\nThis allows for type-safe (at compile-time) and “dimensionality-safe” (at runtime) concatenation.\nConcatenating two UnaryBlockOperators yields a new UnaryBlockOperator. Concatenating a BlockSupplier and a UnaryBlockOperators yields a new BlockSupplier.\n\n\nCode\nBlockSupplier&lt;UnsignedByteType&gt; blocks = BlockSupplier.of(img);\nUnaryBlockOperator&lt;UnsignedByteType, UnsignedByteType&gt; operator =\n        Downsample.createOperator(new UnsignedByteType(), ComputationType.FLOAT, Downsample.Offset.HALF_PIXEL, 2);\n\nBlockSupplier&lt;UnsignedByteType&gt; concatenation = blocks.andThen(operator);\n\n\nNote, that creating the operator we had to specify source type (new UnsignedByteType() and number of source dimensions (2). These must match those of blocks, so we could also directly get them from the thing we are concatenating to.\nTo avoid this duplication, BlockSupplier.andThen(...) also accepts operator factory functions.\n\n\nCode\nBlockSupplier&lt;UnsignedByteType&gt; blocks = BlockSupplier.of(img);\nlong[] size = img.dimensionsAsLongArray();\n\n\nTry to run the following cell multiple times…\n\n\nCode\nblocks = blocks.andThen(\n    Downsample.downsample(ComputationType.FLOAT, Downsample.Offset.HALF_PIXEL));\nsize = Downsample.getDownsampledDimensions(size);\n\nbyte[] data = new byte[(int)(size[0] * size[1])];\nblocks.copy(new long[] {0,0}, data, Util.long2int(size));\ndisplay(ArrayImgs.unsignedBytes(data, size));\n\n\n\n\n\n\n\n\n\nf37d4e03-cfa7-4716-8af5-cc44b5682821\n\n\n\n\nWrap as CellImg\n\n\nCode\nRandomAccessibleInterval&lt;UnsignedByteType&gt; cellImg = blocks.toCellImg(size, 64);\ndisplay(cellImg);\n\n\n\n\n\n\n\n\n\n8ea39058-2206-4aca-a995-7779e2925ad7\n\n\n\n\nProcess in Tiles\nBlockSupplier.tile(...) splits the computation of a requested target interval into computations of sub-intervals of a specified (maximum) size. The results are stored into temporary buffers and then copied into the target primitive array.\nApplications for this are: * Computing large outputs (e. g. to write to N5 or wrap as ArrayImg) with operators that have better performance with smaller block sizes. * Avoiding excessively large blocks (e. g. when chaining multiple downsampling operators).\n\n\nCode\nblocks = blocks.tile(16);\nblocks.copy(new long[] {0,0}, data, Util.long2int(size));\ndisplay(ArrayImgs.unsignedBytes(data, size));\n\n\n\n\n\n\n\n\n\n4ff02cba-3d98-47a9-b848-a8bbd1a0c774"
  },
  {
    "objectID": "posts/05-blocks/05-blocks.html#advanced-examples",
    "href": "posts/05-blocks/05-blocks.html#advanced-examples",
    "title": "Using the ImgLib2 blocks API",
    "section": "Advanced examples",
    "text": "Advanced examples\n\nWorks with VolatileViews\nLoad and show a bigger 3D image (834x388x357).\n\n\nCode\nimport net.imglib2.algorithm.blocks.convert.Convert;\nimport net.imglib2.algorithm.blocks.convolve.Convolve;\nimport net.imglib2.algorithm.blocks.downsample.Downsample;\nimport net.imglib2.algorithm.blocks.transform.Transform;\nimport static net.imglib2.view.fluent.RandomAccessibleIntervalView.Extension.*;\nimport bdv.util.*;\nimport bdv.viewer.DisplayMode;\n\nString fn = \"e002_stack_fused-8bit.tif\";\nRandomAccessibleInterval&lt;UnsignedByteType&gt; img = ImageJFunctions.wrap(IJ.openImage(fn));\nlong[] size = img.dimensionsAsLongArray();\n\nBdv bdv = BdvFunctions.show(img, fn);\nbdv.getBdvHandle().getViewerPanel().setDisplayMode(DisplayMode.SINGLE);\n\n\nExtend the image, make a BlockSupplier, convert to FloatType, apply Gaussian smoothing, and cache in a CellImg.  For showing it in BigDataViewer, we wrap it VolatileViews.wrapAsVolatile(...) for asynchronous (lazy) loading, so that we can see it working.\n\n\nCode\nimport net.imglib2.type.numeric.ARGBType;\nimport bdv.util.volatiles.VolatileViews;\nimport bdv.cache.SharedQueue;\n\nRandomAccessibleInterval&lt;FloatType&gt; downsampledAndSmoothed = BlockSupplier\n        .of(img.view().extend(mirrorDouble()))\n        .andThen(Convert.convert(new FloatType()))\n        .andThen(Convolve.gauss(3))\n        .toCellImg(size, 32);\n\nBdvSource source = BdvFunctions.show(\n        VolatileViews.wrapAsVolatile(downsampledAndSmoothed, new SharedQueue(8)),\n        \"destImg\",\n        Bdv.options().addTo(bdv));\n\nsource.setColor(new ARGBType(0x00ff00));\nsource.setDisplayRange(0, 255);\n\n\n\n\nInfluence of tiling on memory and performance\n\n\nCode\nimport net.imglib2.realtransform.AffineTransform3D;\n\nAffineTransform3D affine = new AffineTransform3D();\naffine.rotate(2, 0.3);\naffine.rotate(1, 0.1);\naffine.rotate(0, 0.6);\naffine.scale(0.9);\n\nlong[] min = {0, 0, 0};\nlong[] size = {512, 512, 1};\nbyte[] dest = new byte[(int) Intervals.numElements(size)];\n\nBlockSupplier&lt;UnsignedByteType&gt; blocks = BlockSupplier\n        .of(img.view().extend(mirrorDouble()))\n        .andThen(Convert.convert(new FloatType()))\n        .andThen(Downsample.downsample())\n        .andThen(Transform.affine(affine, Transform.Interpolation.NLINEAR))\n        //.tile(32)\n        .andThen(Convert.convert(new UnsignedByteType()));\n\nblocks.copy(min, dest, Util.long2int(size));\ndisplay(ArrayImgs.unsignedBytes(dest, size));\n\n\nEvalException: Java heap space\n\n\nWhat is a good tile size? Not too small, not too big…  Let’s look at performance. Play around a bit with which operations to chain.\n\n\nCode\npublic static long timeIt(int numIterations, Runnable r) {\n    long start = System.currentTimeMillis();\n    for (int i = 0; i &lt; numIterations; i++) {\n        r.run();\n    }\n    return (System.currentTimeMillis() - start) / numIterations;\n}\n\nBlockSupplier&lt;UnsignedByteType&gt; blocks = BlockSupplier\n        .of(img.view().extend(mirrorDouble()))\n        .andThen(Convert.convert(new FloatType()))\n        .andThen(Downsample.downsample())\n        .andThen(Transform.affine(affine, Transform.Interpolation.NLINEAR))\n        .andThen(Convert.convert(new UnsignedByteType()));\n\nint[] tileSizes = {4, 8, 16, 32};\n\nfor (int j = 0; j &lt; 3; j++) {\n    for (int tileSize : tileSizes) {\n        BlockSupplier&lt;UnsignedByteType&gt; tiledBlocks = blocks.tile(tileSize);\n        long millis = timeIt(5, () -&gt; tiledBlocks.copy(min, dest, Util.long2int(size)));\n        System.out.println(\"tile size = \" + tileSize + \": \" + millis + \" ms\");\n    }\n    System.out.println();\n}\n\n\ntile size = 4: 123 ms\ntile size = 8: 98 ms\ntile size = 16: 111 ms\ntile size = 32: 167 ms\n\ntile size = 4: 117 ms\ntile size = 8: 102 ms\ntile size = 16: 109 ms\ntile size = 32: 174 ms\n\ntile size = 4: 123 ms\ntile size = 8: 95 ms\ntile size = 16: 125 ms\ntile size = 32: 180 ms"
  },
  {
    "objectID": "posts/02-lazy-imglib2/02-lazy-imglib2.html",
    "href": "posts/02-lazy-imglib2/02-lazy-imglib2.html",
    "title": "ImgLib2 is lazy",
    "section": "",
    "text": "In this notebook, we will learn about the various ways in which ImgLib2 is lazy.\nFirst let’s add the necessary dependencies. We will use ImageJ to load example images and to generate RenderedImage outputs that we can use to render in the notebook. Then, we will import ImgLib2 and the modules to share data between ImgLib2 and ImageJ and the imglib2-realtransform module that includes various transformations.\nCode\n%mavenRepo scijava.public https://maven.scijava.org/content/groups/public\n%maven net.imglib2:imglib2:7.1.2\n%maven net.imglib2:imglib2-realtransform:4.0.3\n%maven net.imglib2:imglib2-ij:2.0.3\n%maven org.scijava:scijava-common:2.99.0\n%maven sc.fiji:bigdataviewer-core:10.6.2\n\nimport bdv.util.*;\nimport bdv.util.volatiles.*;\nimport bdv.viewer.*;\nimport ij.*;\nimport io.github.spencerpark.jupyter.kernel.display.common.*;\nimport io.github.spencerpark.jupyter.kernel.display.mime.*;\nimport net.imglib2.*;\nimport net.imglib2.algorithm.gauss3.*;\nimport net.imglib2.cache.img.*;\nimport net.imglib2.img.imageplus.*;\nimport net.imglib2.img.display.imagej.*;\nimport net.imglib2.loops.*;\nimport net.imglib2.parallel.*;\nimport net.imglib2.position.*;\nimport net.imglib2.realtransform.*;\nimport net.imglib2.type.numeric.*;\nimport net.imglib2.type.numeric.integer.*;\nimport net.imglib2.util.*;\nimport net.imglib2.view.*;\nimport static net.imglib2.view.fluent.RandomAccessibleIntervalView.Extension.*;\nLet’s open one of ImageJ’s example images and show it in the notebook. This uses Spencer Park’s image renderer:\nCode\nvar imp = IJ.openImage(\"./clown.jpg\");\nimp.getBufferedImage();\nIf we want to work with this image in ImgLib2, we need to provide it as an ImgLib2 interface:\nCode\nvar imp = IJ.openImage(\"./clown.jpg\");\n// for later use without the compiler losing its mind, we must provide type information\n// for the ImagePlus wrapper, so let's not use var here\nRandomAccessibleInterval&lt;?&gt; rai = ImagePlusImgs.from(imp);\nrai;\n\n\nIntImagePlus [320x200]\nThere is no default renderer for ImgLib2 interfaces available to the notebook kernel, so we see a default String representation of the result (when rendering this cell the first time). So let’s register some simple renderers that use ImgLib2’s ImageJ bridge and Spencer Park’s image renderer to render ImgLib2 data into the notebook. We add a version that renders the first 2D slice of a RandomAccessibleInterval and a second version that renders a default interval 512x512+0+0 of the 2D slice at position 0 in all other dimensions of an infinite RandomAccessible.\nCode\ngetKernelInstance().getRenderer().createRegistration(RandomAccessibleInterval.class)\n        .preferring(MIMEType.IMAGE_PNG)\n        .supporting(MIMEType.IMAGE_JPEG, MIMEType.IMAGE_GIF)\n        .register((rai, context) -&gt; Image.renderImage(\n                ImageJFunctions.wrap(rai, rai.toString()).getBufferedImage(),\n                context));\n\ngetKernelInstance().getRenderer().createRegistration(RandomAccessible.class)\n        .preferring(MIMEType.IMAGE_PNG)\n        .supporting(MIMEType.IMAGE_JPEG, MIMEType.IMAGE_GIF)\n        .register((ra, context) -&gt; Image.renderImage(\n                ImageJFunctions.wrap(\n                        Views.interval(\n                                ra,\n                                new FinalInterval(\n                                        Arrays.copyOf(\n                                                new long[]{1024, 1024},\n                                                ra.numDimensions()))),\n                        ra.toString()).getBufferedImage(),\n                context));\nNow let’s try the same again:\nCode\nvar imp = IJ.openImage(\"./clown.jpg\");\n// for later use without the compiler losing its mind, we must provide type information\n// for the ImagePlus wrapper, so let's not use var here\nRandomAccessibleInterval&lt;?&gt; rai = ImagePlusImgs.from(imp);\ndisplay(rai, \"image/gif\");\n//display(rai, \"image/jpeg\");\n//display(rai, \"image/png\");\n\n\nIntImagePlus [320x200]\n\n\nbbfdd514-2046-4a90-8f91-70f50e2afa28\nOk, great! Let’s try the ‘infinite’ version:\nCode\nvar ra = Views.extendPeriodic(rai);\nra;\nWonderful! We can of course still render a String representation or alternative encodings with the injected display methods of the kernel:\nCode\ndisplay(rai, \"text/plain\");\ndisplay(ra, \"text/plain\");\ndisplay(rai, \"image/jpeg\");\ndisplay(ra, \"image/gif\");\n\n\nIntImagePlus [320x200]\n\n\nnet.imglib2.view.ExtendedRandomAccessibleInterval@26003768\n\n\n\n\n\n\n\n\n\nnet.imglib2.view.ExtendedRandomAccessibleInterval@26003768\n\n\ndcf18908-52e5-4fa3-9254-5ccaa48fc4e6\nYou may have noticed that the output of this cell ends with an obscure identifier. We see this, because we did not catch the output of the display method which provides an identifier for the output object that it generates. This identifier can be used to update the contents of this object. We can use this to render simple animations, e.g. to slice through a 3D volume. Let’s try this with a 3D volume from the ImageJ example images:\nCode\nvar imp = IJ.openImage(\"https://mirror.imagej.net/ij/images/flybrain.zip\");\nRandomAccessibleInterval&lt;?&gt; rai = ImagePlusImgs.from(imp);\nvar refSlice = display(Views.hyperSlice(rai, 2, rai.dimension(2) / 2), \"image/jpeg\");\nvar refLabel = display(\"slice \" + rai.dimension(2) / 2);\nfor (int z = 0; z &lt; rai.dimension(2); ++z) {\n    var slice = Views.hyperSlice(rai, 2, z);\n    updateDisplay(refSlice, slice, \"image/jpeg\");\n    updateDisplay(refLabel, \"slice \" + z);\n    Thread.sleep(100);\n}\n// for static notebook export\nupdateDisplay(refSlice, Views.hyperSlice(rai, 2, rai.dimension(2) / 2), \"image/jpeg\");\n\n\n\n\n\n\n\n\n\nslice 56\nOf course, you can only see the animation if you actually run the notebook cell. In a future iteration, we are planning to implement an animated GIF generator for offline animations, but not this time. Let’s see what else we can do with these renderers.\nFirst, let’s apply some transformations to images. Already in the above border extension example as well as in the slicing animation, we have used ImgLib2’s default behavior to apply transformations lazily, i.e. only when a ‘pixel’ is actually queried (e.g. to render it into a RenderedImage raster), the transformations are applied. Transformations can be applied to both coordinates and values. Lets apply some transformations to values:\nCode\nimport net.imglib2.converter.*;\nimport net.imglib2.type.numeric.*;\n\nvar imp = IJ.openImage(\"https://mirror.imagej.net/ij/images/clown.jpg\");\nRandomAccessibleInterval&lt;ARGBType&gt; rai = ImagePlusImgs.from(imp);\ndisplay(Converters.argbChannel(rai, 1));\ndisplay(\"red\");\ndisplay(Converters.argbChannel(rai, 2));\ndisplay(\"green\");\ndisplay(Converters.argbChannel(rai, 3));\ndisplay(\"blue\");\n\ndisplay(\n        Converters.&lt;ARGBType, ARGBType&gt;convert2(\n                rai,\n                (in, out) -&gt; {\n    \n                    final int argb = in.get();\n                    final double grey = 0.3 * ARGBType.red(argb) + 0.6 * ARGBType.green(argb) + 0.1 * ARGBType.blue(argb);\n                    out.set(ARGBType.rgba(255 - grey, grey, grey, 255));\n                },\n                ARGBType::new));\ndisplay(\"grey to red-cyan ramp\");\n\n\n\n\n\n\n\n\n\nred\n\n\n\n\n\n\n\n\n\ngreen\n\n\n\n\n\n\n\n\n\nblue\n\n\n\n\n\n\n\n\n\ngrey to red-cyan ramp\n\n\n9cfd8948-83a2-462d-836e-72892d3dcd03\nAnd now some integer coordinate transformations:\nCode\ndisplay(Views.invertAxis(rai, 0));\ndisplay(\"flip axis 0\");\n\ndisplay(Views.permute(rai, 0, 1));\ndisplay(\"permute axes\");\n\ndisplay(Views.extendMirrorSingle(rai));\ndisplay(\"mirror extension without repeated border pixels\");\n\ndisplay(Views.subsample(Views.shear(Views.extendPeriodic(rai), 0, 1), 3, 1));\ndisplay(\"extend periodically, shear axis 1 into axis 0, subsample by (3, 1)\");\n\n\n\n\n\n\n\n\n\nflip axis 0\n\n\n\n\n\n\n\n\n\npermute axes\n\n\n\n\n\n\n\n\n\nmirror extension without repeated border pixels\n\n\n\n\n\n\n\n\n\nextend periodically, shear axis 1 into axis 0, subsample by (3, 1)\n\n\n13ce9c52-c37e-4d0e-9baf-30619d963815\nWhile most trivial integer transformations such as flipping axes work on intervals, you probably noticed that we had to extend the image to infinity in order to shear it, so ImgLib2 can provide values for coordinates outside of the source interval. For real coordinate transformations we will also need to interpolate values at non-integer coordinates. Finally, in order to render the result, we have to read it from a raster. Let’s do this:\nCode\nimport net.imglib2.interpolation.randomaccess.*;\nimport net.imglib2.realtransform.*;\n\nvar imp = IJ.openImage(\"https://mirror.imagej.net/ij/images/clown.jpg\");\nRandomAccessibleInterval&lt;ARGBType&gt; rai = ImagePlusImgs.from(imp);\nvar ra = Views.extendValue(rai, new ARGBType(0xff00ff00)); // &lt; green background\nvar interpolated = Views.interpolate(ra, new ClampingNLinearInterpolatorFactory&lt;&gt;()); // n-linear interpolation\n/**\n * This would be\n * var interpolated = Views.interpolate(ra, new NLinearInterpolatorFactory&lt;&gt;());\n * if you have no concern about value overflows\n */\nvar affine = new AffineTransform2D();\nvar transformed = Views.interval(RealViews.affine(interpolated, affine), rai); // shortcut for affines\nvar refImage = display(transformed, \"image/jpeg\");\nvar refLabel = display(\"\", \"text/html\");\n\nfinal int steps = 20;\nfor (int i = 0; i &lt; steps; ++i) {\n    affine.translate(-rai.dimension(0) / 2, -rai.dimension(1) / 2);\n    affine.rotate(Math.PI / 6.0 / steps);\n    affine.scale(1.0 + 0.7 / steps);\n    affine.translate(rai.dimension(0) / 2, rai.dimension(1) / 2);\n    \n    updateDisplay(refImage, Views.interval(transformed, rai), \"image/jpeg\");\n    updateDisplay(\n            refLabel,\n            String.format(\"\"\"\n                            &lt;p&gt;affine transformation matrix:&lt;/p&gt;\n                            &lt;table&gt;\n                            &lt;tr&gt;&lt;td&gt;%.2f&lt;/td&gt;&lt;td&gt;%.2f&lt;/td&gt;&lt;td&gt;%.2f&lt;/td&gt;&lt;/tr&gt;\n                            &lt;tr&gt;&lt;td&gt;%.2f&lt;/td&gt;&lt;td&gt;%.2f&lt;/td&gt;&lt;td&gt;%.2f&lt;/td&gt;&lt;/tr&gt;\n                            &lt;/table&gt;\"\"\",\n                    affine.get(0, 0), affine.get(0, 1), affine.get(0, 2),\n                    affine.get(1, 0), affine.get(1, 1), affine.get(1, 2)), \"text/html\");\n    Thread.sleep(100);\n}\n\n\n\n\n\n\n\n\n\n\naffine transformation matrix:\n\n\n\n\n1.72\n-0.99\n-16.22\n\n\n0.99\n1.72\n-231.50\nAffine transformation are probably the most well known and simple real coordinate transformations, but there are many more. Let’s try a ThinplateSplineTransform and format text output with markdown:\nCode\nvar refImage = display(rai, \"image/jpeg\");\nvar refLabel = display(\"\", \"text/markdown\");\n\nint steps = 20;\ndouble stretch = 40;\nfor (int i = 0; i &lt; steps; ++i) {\n    final double offset = stretch * i / steps;\n    final double[][] p = {\n            {0, rai.dimension(0), 0, rai.dimension(0), rai.dimension(0) * 0.25, rai.dimension(0) * 0.75, rai.dimension(0) * 0.25, rai.dimension(0) * 0.75},\n            {0, 0, rai.dimension(1), rai.dimension(1), rai.dimension(1) * 0.25, rai.dimension(1) * 0.25, rai.dimension(1) * 0.75, rai.dimension(1) * 0.75}\n    };\n    final double[][] q = {\n            {0, rai.dimension(0), 0, rai.dimension(0),\n            rai.dimension(0) * 0.25 + offset , rai.dimension(0) * 0.75 - offset, rai.dimension(0) * 0.25 + offset, rai.dimension(0) * 0.75 - offset},\n            {0, 0, rai.dimension(1), rai.dimension(1),\n            rai.dimension(1) * 0.25 + offset, rai.dimension(1) * 0.25 + offset, rai.dimension(1) * 0.75 - offset, rai.dimension(1) * 0.75 - offset}\n    };\n    final var transform = new ThinplateSplineTransform(p, q);\n    final var warped = new RealTransformRandomAccessible&lt;&gt;(interpolated, transform);\n    String text = \"\"\"\nthinplate spline transformation controls points:\n            \n| | p&lt;sub&gt;x&lt;/sub&gt; | p&lt;sub&gt;y&lt;/sub&gt; | q&lt;sub&gt;x&lt;/sub&gt; | q&lt;sub&gt;y&lt;/sub&gt; |\n| --- | ---: | ---: | ---: | ---: |\n\"\"\";\n    for (int j = 0; j &lt; p[0].length; ++j)\n        text += String.format(\"\"\"\n| %d | %.2f | %.2f | %.2f | %.2f |\n\"\"\",\n                j, p[0][j], p[1][j], q[0][j], q[1][j]);                \n\n    updateDisplay(refImage, Views.interval(warped, rai), \"image/jpeg\");\n    updateDisplay(refLabel, text, \"text/markdown\");\n\n    Thread.sleep(100);\n}\n\n\n\n\n\n\n\n\n\nthinplate spline transformation controls points:\n\n\n\n\npx\npy\nqx\nqy\n\n\n\n\n0\n0.00\n0.00\n0.00\n0.00\n\n\n1\n320.00\n0.00\n320.00\n0.00\n\n\n2\n0.00\n200.00\n0.00\n200.00\n\n\n3\n320.00\n200.00\n320.00\n200.00\n\n\n4\n80.00\n50.00\n118.00\n88.00\n\n\n5\n240.00\n50.00\n202.00\n88.00\n\n\n6\n80.00\n150.00\n118.00\n112.00\n\n\n7\n240.00\n150.00\n202.00\n112.00\n\n\n\n\n\nSLF4J: Failed to load class \"org.slf4j.impl.StaticLoggerBinder\".\nSLF4J: Defaulting to no-operation (NOP) logger implementation\nSLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details."
  },
  {
    "objectID": "posts/02-lazy-imglib2/02-lazy-imglib2.html#procedurally-generated-image",
    "href": "posts/02-lazy-imglib2/02-lazy-imglib2.html#procedurally-generated-image",
    "title": "ImgLib2 is lazy",
    "section": "Procedurally generated image",
    "text": "Procedurally generated image\nWe define the Juliaset as a function in 2D real space using a BiConsumer lambda function. The BiConsumer receives two parameters, the first one (x) is the 2D coordinate, the second one (fx) is the target of the function whose value will be set in place, here we use an UnsignedByteType. We also have to provide a Supplier for instances of the target such that multiple threads can each create their own.\nThe result is a function over continuous coordinates that is unbounded.\n\n\nCode\nvar juliaset = new FunctionRealRandomAccessible&lt;UnsignedByteType&gt;(\n    2,\n    (x, fx) -&gt; {\n      int i = 0;\n      double v = 0;\n      double c = x.getDoublePosition(0);\n      double d = x.getDoublePosition(1);\n      for (; i &lt; 255 && v &lt; 4096; ++i) {\n        final double e = c * c - d * d;\n        d = 2 * c * d;\n        c = e + 0.3;\n        d += 0.6;\n        v = Math.sqrt(c * c + d * d);\n        ++i;\n      }\n      fx.set(i);\n    },\n    UnsignedByteType::new);\n\nBdvSource bdv = BdvFunctions.show(\n    juliaset,\n    Intervals.createMinMax(-1, -1, 1, 1),\n    \"juliaset\",\n    Bdv.options().is2D());\nbdv.setDisplayRange(0, 127);"
  },
  {
    "objectID": "posts/02-lazy-imglib2/02-lazy-imglib2.html#caching-results-of-expensive-operations",
    "href": "posts/02-lazy-imglib2/02-lazy-imglib2.html#caching-results-of-expensive-operations",
    "title": "ImgLib2 is lazy",
    "section": "Caching results of expensive operations",
    "text": "Caching results of expensive operations\nTrying to show benefits of caching with very contrived example…\nUse the juliaset from above. To have something that can be put in a cache, we rasterize (virtually)\n\n\nCode\nvar transform = new AffineTransform2D();\ntransform.set(\n    4000, 0, 8000,\n    0, 4000, 8000);\nvar affine = RealViews.affine(juliaset, transform);\n\nvar transformed = affine\n    .view()\n    .interval(Intervals.createMinSize(0, 0, 16000, 16000))\n    .convert(UnsignedByteType::new, (i, o) -&gt; o.set(Math.min(i.get() * 3, 255)));\n\nvar bdv = BdvFunctions.show(\n    transformed,\n    \"transformed and rasterized\",\n    Bdv.options().is2D());\nbdv.getBdvHandle().getViewerPanel().setDisplayMode(DisplayMode.SINGLE);\n\n\nIt is relatively expensive (not really, but use your imagination) to compute the value of a pixel in transformed. And the value is re-computed everytime it is accessed.\nTo avoid that, we can wrap it into a CachedCellImg. Pixel values are computed once and cached for subsequent accesses.\nThe CachedCellImg pre-computes whole blocks of data when a single pixel from the block is accessed. This is often what you want, but you should be aware of it.\nTo make things more interesting for the next experiment, we use arbitrary prime numbers for cell sizes.\n\n\nCode\nvar cached = new ReadOnlyCachedCellImgFactory().create(\n    transformed.dimensionsAsLongArray(),\n    new UnsignedByteType(),\n    cell -&gt; LoopBuilder.setImages(transformed.view().interval(cell), cell).forEachPixel((i, o) -&gt; o.set(i)),\n    ReadOnlyCachedCellImgOptions.options().cellDimensions(359));\n\nBdvFunctions.show(\n    VolatileViews.wrapAsVolatile(cached),\n    \"cached\",\n    Bdv.options().addTo(bdv));\n\n\nbdv.util.BdvStackSource@3102ff8e\n\n\nWe define two additional CachedCellImgs: one that generates data by smoothing the procedural image, one that generates data by smoothing the cached image.\nSince we use arbitrary prime numbers for cell sizes, the operation on the original image starts immediately, and the operation on the cached image requires that the cached source cells are being generated. We run everything in a single thread, so you see some interesting processing patterns.\nTo start the show, you have to switch to fused mode which shows all sources that we added to BigDataViewer.\n\n\nCode\nvar convolved = new ReadOnlyCachedCellImgFactory().create(\n    transformed.dimensionsAsLongArray(),\n    new UnsignedByteType(),\n    cell -&gt; Parallelization.runSingleThreaded(() -&gt; Gauss3.gauss(new double[]{8, 8}, transformed, cell)),\n    ReadOnlyCachedCellImgOptions.options().cellDimensions(523));\n\nvar source = BdvFunctions.show(\n    VolatileViews.wrapAsVolatile(convolved),\n    \"convolved\",\n    Bdv.options().addTo(bdv));\nsource.setColor(new ARGBType(0xff00ff));\n\nvar cachedConvolved = new ReadOnlyCachedCellImgFactory().create(\n    transformed.dimensionsAsLongArray(),\n    new UnsignedByteType(),\n    cell -&gt; Parallelization.runSingleThreaded(() -&gt; Gauss3.gauss(new double[]{8, 8}, cached.view().extend(mirrorDouble()), cell)),\n    ReadOnlyCachedCellImgOptions.options().cellDimensions(523));\n\nvar source = BdvFunctions.show(\n    VolatileViews.wrapAsVolatile(cachedConvolved),\n    \"cached convolved\",\n    Bdv.options().addTo(bdv));\nsource.setColor(new ARGBType(0x00ff00));"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Lazy Parallel Processing and Visualization of Large Data with ImgLib2, BigDataViewer, the N5-API, and Spark",
    "section": "",
    "text": "Setup instructions\n\n\n\n\n\n\nconda\n\n\njava\n\n\nijava\n\n\njupyter\n\n\nquarto\n\n\n\nHow to get started …\n\n\n\n\n\nOct 17, 2024\n\n\nStephan Saalfeld\n\n\n\n\n\n\n\n\n\n\n\n\nImgLib2 is lazy\n\n\n\n\n\n\nimglib2\n\n\njupyter\n\n\nnotebook\n\n\n\n… very, very lazy, like … everywhere!\n\n\n\n\n\nOct 17, 2024\n\n\nStephan Saalfeld, Tobias Pietzsch\n\n\n\n\n\n\n\n\n\n\n\n\nN5 API\n\n\n\n\n\n\nimglib2\n\n\njava\n\n\nn5\n\n\nhdf5\n\n\nzarr\n\n\njupyter\n\n\nnotebook\n\n\n\nRead and write ImgLib2 data with the N5 API.\n\n\n\n\n\nOct 17, 2024\n\n\nStephan Saalfeld\n\n\n\n\n\n\n\n\n\n\n\n\nLazy image processing with ImgLib2 cache\n\n\n\n\n\n\nimglib2\n\n\njupyter\n\n\nnotebook\n\n\ncache\n\n\nlazy\n\n\ncell\n\n\n\n… by defining the processing operations over cells.\n\n\n\n\n\nOct 17, 2024\n\n\nStephan Saalfeld\n\n\n\n\n\n\n\n\n\n\n\n\nUsing the ImgLib2 blocks API\n\n\n\n\n\n\nimglib2\n\n\njava\n\n\nn5\n\n\njupyter\n\n\nnotebook\n\n\n\nUsing the ImgLib2 blocks API for downsampling and convolution\n\n\n\n\n\nOct 17, 2024\n\n\nTobias Pietzsch\n\n\n\n\n\n\n\n\n\n\n\n\nLazy processing with ImgLib2 and Spark\n\n\n\n\n\n\nimglib2\n\n\njupyter\n\n\nnotebook\n\n\nspark\n\n\n\nWorking around (lack of) serialization.\n\n\n\n\n\nOct 17, 2024\n\n\nStephan Saalfeld\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/06-spark/06-spark.html",
    "href": "posts/06-spark/06-spark.html",
    "title": "Lazy processing with ImgLib2 and Spark",
    "section": "",
    "text": "In this notebook, we will learn how to use what we learned about lazy evaluation with ImgLib2 on a Spark cluster.\nSpark depends on all methods and data to be serializable. You can use Java’s default serialization, or you can implement your own custom serializers. For this workshop, we will depend on default serialization, and we will work around things that are not serializable by default (e.g. all of [ImgLib2] and [N5]).\nFor the Spark tutorial, we will work with an actual Java application from our favorite IDE. Please import the small project in /i2k2024-lazy-utils.\nThe main application is org.janelia.saalfeldlab.i2k2024.SparkWorkshop. For local experiments, we can start this with the runtime parameters:\nand application parameters e.g.:\nYou can observe the running application from the standard URL of Spark’s WebUI http://localhost:4040."
  },
  {
    "objectID": "posts/06-spark/06-spark.html#tricks-to-make-it-more-efficient",
    "href": "posts/06-spark/06-spark.html#tricks-to-make-it-more-efficient",
    "title": "Lazy processing with ImgLib2 and Spark",
    "section": "Tricks to make it more efficient",
    "text": "Tricks to make it more efficient\nA Spark cluster consists of Worker Nodes (computers) that run Executors (JVMs), each running Tasks (in Threads). Since we do not want to serialize complicated large data across the Spark cluster, each task has to open readers, writers, and the entire image:\nrddGrid.foreach(gridBlock -&gt; {\n\n  final var n5 = new N5Factory().openReader(n5Url);\n  final RandomAccessibleInterval&lt;T&gt; img = N5Utils.open(n5, n5Dataset);\n\n  /* Use the new ImageJ plugin contrast limited local contrast normalization */\n  final var cllcn =\n      new ImageJStackOp&lt;T&gt;(\n          Views.extendZero(img),\n          (fp) -&gt; new CLLCN(fp).run(\n              blockRadius,\n              blockRadius,\n              3f,\n              10,\n              0.5f,\n              true,\n              true,\n              true),\n          blockRadius,\n          0,\n          65535);\n\n  /* create a cached image factory with reasonable default values */\n  final var cacheFactory = new ReadOnlyCachedCellImgFactory(\n      new ReadOnlyCachedCellImgOptions()\n          .volatileAccesses(true)         // &lt; use volatile accesses for display\n          .cellDimensions(256, 256, 32)); // &lt; standard block size for this example\n\n  final var cllcned = cacheFactory.create(\n      img.dimensionsAsLongArray(),    // &lt; the size of the result\n      img.getType().createVariable(), // &lt; the type that is used to generate the result pixels\n      cllcn::accept);                 // &lt; the consumer that creates each cell\n\n  /* crop the block of interest */\n  final var block = Views.offsetInterval(cllcned, gridBlock[0], gridBlock[1]);\n\n  final N5Writer n5Writer = new N5Factory().openWriter(n5OutUrl);\n  N5Utils.saveNonEmptyBlock(\n      block,\n      n5Writer,\n      n5OutDataset,\n      gridBlock[2],\n      img.getType().createVariable());\n  });\nThis is not a problem in itself because opening those readers and images is lazy and amounts to the work required to serialize and deserialize from meta-data (except for storage services with slow authentication…). However, we have learned that ImgLib2 cache stores the lazily generated results, and with the naive approach above, we do not re-use cached results, because each threads produces their own independent cache. With a simple trick, we can make sure that all our objects are Singletons per JVM, such that all Tasks on an Executor share the same objects and cell cache:\nimport net.imglib2.algorithm.util.Singleton;\n// [...]\nrddGrid.foreach(gridBlock -&gt; {\n\n  final var n5 = Singleton.get(\n      \"n5\" + n5Url,\n      () -&gt; new N5Factory().openReader(n5Url));\n  final RandomAccessibleInterval&lt;T&gt; img = Singleton.get(\n      \"img\" + n5Dataset,\n      () -&gt; (RandomAccessibleInterval&lt;T&gt;)N5Utils.open(n5, n5Dataset));\n\n  final var cllcned = Singleton.get(\n      \"cllcned\" + n5OutDataset,\n      () -&gt; {\n\n        /* Use the new ImageJ plugin contrast limited local contrast normalization */\n        final var cllcn =\n            new ImageJStackOp&lt;T&gt;(\n                Views.extendZero(img),\n                (fp) -&gt; new CLLCN(fp).run(\n                    blockRadius,\n                    blockRadius,\n                    3f,\n                    10,\n                    0.5f,\n                    true,\n                    true,\n                    true),\n                blockRadius,\n                0,\n                65535);\n\n        /* create a cached image factory with reasonable default values */\n        final var cacheFactory = new ReadOnlyCachedCellImgFactory(\n            new ReadOnlyCachedCellImgOptions()\n                .volatileAccesses(true)         // &lt; use volatile accesses for display\n                .cellDimensions(256, 256, 32)); // &lt; standard block size for this example\n\n        return (RandomAccessibleInterval&lt;T&gt;)cacheFactory.create(\n            img.dimensionsAsLongArray(),    // &lt; the size of the result\n            img.getType().createVariable(), // &lt; the type that is used to generate the result pixels\n            cllcn::accept);                 // &lt; the consumer that creates each cell\n      });\n\n    /* crop the block of interest */\n    final var block = Views.offsetInterval(cllcned, gridBlock[0], gridBlock[1]);\n\n    final N5Writer n5Writer = Singleton.get(\n            \"n5Writer\" + n5OutUrl,\n            () -&gt; new N5Factory().openWriter(n5OutUrl));\n\n    N5Utils.saveNonEmptyBlock(\n            block,\n            n5Writer,\n            n5OutDataset,\n            gridBlock[2],\n            img.getType().createVariable());\n});\nMore tricks in the future…"
  },
  {
    "objectID": "posts/03-n5/03-n5.html",
    "href": "posts/03-n5/03-n5.html",
    "title": "N5 API",
    "section": "",
    "text": "In this notebook, we will learn how to work with the N5 API and ImgLib2.\nThe N5 API unifies block-wise access to potentially very large n-dimensional data over a variety of hierarchical storage backends. Those backends currently are the HDF5 file format, Zarr, and the N5 format. The ImgLib2 bindings use this API to make this data available as memory cached lazy cell images through ImgLib2.\nFirst let’s add the necessary dependencies. We will load the n5-ij module which will transitively load ImgLib2 and all the N5 API modules that we will be using in this notebook. It will also load ImageJ which we will use to display data. If this is the first time you are loading dependencies, running this can take quite a while. Next time, everything will be cached though…\n\n\nCode\n%mavenRepo scijava.public https://maven.scijava.org/content/groups/public\n%maven org.janelia.saalfeldlab:n5-ij:4.2.5\n\n\nNext, we register a simple renderer that uses ImgLib2’s ImageJ bridge and Spencer Park’s image renderer to render the first 2D slice of a RandomAccessibleInterval into the notebook. We also add a renderer for arrays and maps, because we want to list directories and attributes maps later.\n\n\nCode\nimport com.google.gson.*;\nimport io.github.spencerpark.jupyter.kernel.display.common.*;\nimport io.github.spencerpark.jupyter.kernel.display.mime.*;\nimport net.imglib2.img.display.imagej.*;\nimport net.imglib2.view.*;\nimport net.imglib2.*;\n\ngetKernelInstance().getRenderer().createRegistration(RandomAccessibleInterval.class)\n    .preferring(MIMEType.IMAGE_PNG)\n    .supporting(MIMEType.IMAGE_JPEG, MIMEType.IMAGE_GIF)\n    .register((rai, context) -&gt; Image.renderImage(\n        ImageJFunctions.wrap(rai, rai.toString()).getBufferedImage(),\n        context));\n\ngetKernelInstance().getRenderer().createRegistration(String[].class)\n    .preferring(MIMEType.TEXT_PLAIN)\n    .supporting(MIMEType.TEXT_HTML, MIMEType.TEXT_MARKDOWN)\n    .register((array, context) -&gt; Text.renderCharSequence(Arrays.toString(array), context));\n\ngetKernelInstance().getRenderer().createRegistration(long[].class)\n    .preferring(MIMEType.TEXT_PLAIN)\n    .supporting(MIMEType.TEXT_HTML, MIMEType.TEXT_MARKDOWN)\n    .register((array, context) -&gt; Text.renderCharSequence(Arrays.toString(array), context));\n\ngetKernelInstance().getRenderer().createRegistration(Map.class)\n    .preferring(MIMEType.TEXT_PLAIN)\n    .supporting(MIMEType.TEXT_HTML, MIMEType.TEXT_MARKDOWN)\n    .register((map, context) -&gt; Text.renderCharSequence(map.toString(), context));\n\n\nWe will now open N5 datasets from some sources as lazy-loading ImgLib2 cell images. For opening the N5 readers, we will use the helper class N5Factory which parses the URL and/ or some magic byte in file headers to pick the right reader or writer for the various possible N5 backends. If you know which backend you are using, you should probably use the appropriate implementation directly, it’s not difficult.\n\n\nCode\nimport ij.*;\nimport net.imglib2.converter.*;\nimport net.imglib2.type.numeric.integer.*;\nimport org.janelia.saalfeldlab.n5.*;\nimport org.janelia.saalfeldlab.n5.ij.*;\nimport org.janelia.saalfeldlab.n5.imglib2.*;\nimport org.janelia.saalfeldlab.n5.universe.*;\n\n/* make an N5 reader, we start with a public container on AWS S3 */\nfinal var n5Url = \"https://janelia-cosem.s3.amazonaws.com/jrc_hela-2/jrc_hela-2.n5\";\nfinal var n5Group = \"/em/fibsem-uint16\";\nfinal var n5Dataset = n5Group + \"/s4\";\nfinal var n5 = new N5Factory().openReader(n5Url);\n\n/* open a dataset as a lazy loading ImgLib2 cell image */\nfinal RandomAccessibleInterval&lt;UnsignedShortType&gt; rai = N5Utils.open(n5, n5Dataset);\n\n/* This is a 3D volume, so let's show the center slice */\nViews.hyperSlice(rai, 2, rai.dimension(2) / 2);\n\n\nSLF4J: Failed to load class \"org.slf4j.impl.StaticLoggerBinder\".\nSLF4J: Defaulting to no-operation (NOP) logger implementation\nSLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details.\n\n\n\n\n\n\n\n\n\nThat’s a bit low on contrast, let’s make it look like TEM, and let’s show a few of those hyperslices through the 3D volume:\n\n\nCode\nvar raiContrast = Converters.convert(\n    rai,\n    (a, b) -&gt; b.setReal(\n        Math.max(\n            0,\n            Math.min(\n                255,\n                255 - 255 * (a.getRealDouble() - 26000) / 6000))),\n    new UnsignedByteType());\ndisplay(Views.hyperSlice(raiContrast, 2, rai.dimension(2) / 10 * 4), \"image/jpeg\");\ndisplay(Views.hyperSlice(raiContrast, 2, rai.dimension(2) / 2), \"image/jpeg\");\ndisplay(Views.hyperSlice(raiContrast, 2, rai.dimension(2) / 10 * 6), \"image/jpeg\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n619d3499-e39d-46f8-8d98-86f9465d3b03\n\n\nWe can list the attributes and their types of every group or dataset, and read any of them into matching types:\n\n\nCode\nvar groupAttributes = n5.listAttributes(n5Group);\nvar datasetAttributes = n5.listAttributes(n5Dataset);\n\ndisplay(\n    \"**\" + n5Group + \"** attributes are ```\" +\n        groupAttributes.toString().replace(\", \", \",\\n\").replace(\"{\", \"{\\n\") + \"```\",\n    \"text/markdown\");\ndisplay(\n    \"**\" + n5Dataset + \"** attributes are ```\" +\n        datasetAttributes.toString().replace(\", \", \",\\n\").replace(\"{\", \"{\\n\") + \"```\",\n    \"text/markdown\");\n\nvar n5Version = n5.getAttribute(\"/\", \"n5\", String.class);\nvar dimensions = n5.getAttribute(n5Dataset, \"dimensions\", long[].class);\nvar compression = n5.getAttribute(n5Dataset, \"compression\", Compression.class);\nvar dataType = n5.getAttribute(n5Dataset, \"dataType\", DataType.class);\n\ndisplay(n5Version);\ndisplay(dimensions);\ndisplay(compression);\ndisplay(dataType);\n\n\n/em/fibsem-uint16 attributes are { pixelResolution=class java.lang.Object, multiscales=class [Ljava.lang.Object;, n5=class java.lang.String, scales=class [Ljava.lang.Object;, axes=class [Ljava.lang.String;, name=class java.lang.String, units=class [Ljava.lang.String;}\n\n\n/em/fibsem-uint16/s4 attributes are { transform=class java.lang.Object, pixelResolution=class java.lang.Object, dataType=class java.lang.String, name=class java.lang.String, compression=class java.lang.Object, blockSize=class [J, dimensions=class [J}\n\n\n2.0.0\n\n\n[750, 100, 398]\n\n\norg.janelia.saalfeldlab.n5.GzipCompression@6e5dcad2\n\n\nuint16\n\n\nab9d40cd-0879-439a-a659-749b93266379\n\n\nLet’s save the contrast adjusted uin8 version of the volume into three N5 supported containers (N5, Zarr, and HDF5), parallelize writing for N5 and Zarr:\n\n\nCode\nimport java.nio.file.*;\n\n/* create a temporary directory */\nPath tmpDir = Files.createTempFile(\"\", \"\");\nFiles.delete(tmpDir);\nFiles.createDirectories(tmpDir);\nvar tmpDirStr = tmpDir.toString();\n\ndisplay(tmpDirStr);\n\n/* get the dataset attributes (dataType, compression, blockSize, dimensions) */\nfinal var attributes = n5.getDatasetAttributes(n5Dataset);\n\n/* use 10 threads to parallelize copy */\nfinal var exec = Executors.newFixedThreadPool(10);\n\n/* save this dataset into a filsystem N5 container */\ntry (final var n5Out = new N5Factory().openFSWriter(tmpDirStr + \"/test.n5\")) {\n  N5Utils.save(\n      raiContrast,\n      n5Out,\n      n5Dataset,\n      attributes.getBlockSize(),\n      attributes.getCompression(),\n      exec);\n}\n\n/* save this dataset into a filesystem Zarr container */\ntry (final var zarrOut = new N5Factory().openZarrWriter(tmpDirStr + \"/test.zarr\")) {\n  N5Utils.save(\n      raiContrast,\n      zarrOut,\n      n5Dataset,\n      attributes.getBlockSize(),\n      attributes.getCompression(),\n      exec);\n}\n\n/* save this dataset into an HDF5 file, parallelization does not help here */\ntry (final var hdf5Out = new N5Factory().openHDF5Writer(tmpDirStr + \"/test.hdf5\")) {\n  N5Utils.save(\n      raiContrast,\n      hdf5Out,\n      n5Dataset,\n      attributes.getBlockSize(),\n      attributes.getCompression());\n}\n\n/* shot down the executor service */\nexec.shutdown();\n\ndisplay(Files.list(tmpDir).map(a -&gt; a.toString()).toArray(String[]::new));\n\n\n/tmp/4321950666369446413\n\n\n[/tmp/4321950666369446413/test.n5, /tmp/4321950666369446413/test.zarr, /tmp/4321950666369446413/test.hdf5]\n\n\ne395f5c9-9538-41d9-8818-385170d654f9\n\n\nNow let us look at them and see if they all contain the same data:\n\n\nCode\ntry (final var n5 = new N5Factory().openReader(tmpDirStr + \"/test.n5\")) {\n  final RandomAccessibleInterval&lt;UnsignedByteType&gt; rai = N5Utils.open(n5, n5Dataset);\n  display(Views.hyperSlice(rai, 2, rai.dimension(2) / 2), \"image/jpeg\");\n}\n\ntry (final var n5 = new N5Factory().openReader(tmpDirStr + \"/test.zarr\")) {\n  final RandomAccessibleInterval&lt;UnsignedByteType&gt; rai = N5Utils.open(n5, n5Dataset);\n  display(Views.hyperSlice(rai, 2, rai.dimension(2) / 2), \"image/jpeg\");    \n}\n\ntry (final var n5 = new N5Factory().openReader(tmpDirStr + \"/test.hdf5\")) {\n  final RandomAccessibleInterval&lt;UnsignedByteType&gt; rai = N5Utils.open(n5, n5Dataset);\n  display(Views.hyperSlice(rai, 2, rai.dimension(2) / 2), \"image/jpeg\");        \n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLet’s clean up temporary storage before we end this tutorial.\n\n\nCode\ntry (var n5 = new N5Factory().openWriter(tmpDirStr + \"/test.n5\")) {\n  n5.remove();\n}\ntry (var n5 = new N5Factory().openWriter(tmpDirStr + \"/test.zarr\")) {\n  n5.remove();\n}\ntry (var n5 = new N5Factory().openWriter(tmpDirStr + \"/test.hdf5\")) {\n  n5.remove();\n}\nFiles.delete(tmpDir);"
  },
  {
    "objectID": "posts/01-setup.html",
    "href": "posts/01-setup.html",
    "title": "Setup instructions",
    "section": "",
    "text": "We will do this workshop in Jupyter notebooks\nIn this workshop, we will learn how to use ImgLib2, BigDataViewer, the N5-API, and Apache Spark for lazy evaluation data processing workflows. We will draft all examples in interactive Jupyter notebooks. For this, we will need to create an environment that runs a Jupyter notebook server, a fast Java kernel, and a few other dependencies. If you don’t have conda installed yet, please do this now by following their installation instructions.\nNow, we can create an environment:\nconda create -c conda-forge -n i2k2024-lazy python=3\nand activate it:\nconda activate i2k2024-lazy\nNow, let’s install the Blosc compression library, the IJava Jupyter kernel, and a modern version of OpenJDK:\nconda install conda-forge::python-blosc\nconda install conda-forge::ijava\nconda install conda-forge::openjdk\nNow, checkout the repository with the code example for our workshop:\ngit clone https://github.com/saalfeldlab/i2k2024-lazy-workshop\nThis repository includes the notebooks for our workshop and renders them into a web-blog using the Quarto publishing system. For our workshop, it is not important to run Quarto, but you may find it exciting to use the same structure for your own experiments. You will find the notebooks as posts in the repository:\ncd i2k2024-lazy-workshop/posts\nHere, please start your Jupyter notebook server and let’s open the first example:\njupyter notebook\nPS: The IJava kernel uses Java’s JShell tool, so in a production environment, you can use JShell and Maven to execute your code. For that, you will have to declare the dependencies in a pom.xml file, and start JShell by:\nmvn com.github.johnpoth:jshell-maven-plugin:1.3:run"
  }
]